pub mod cli;

use std::{
    process::{Command, Stdio, Child, Output}, 
    io::Write, 
    path::{Path, PathBuf}, 
    env::current_dir, 
    time::Duration,
    };
use std::ffi::OsStr;
use std::error::Error;
use cli::Cli;
use process_control::ChildExt;
use process_control::Control;
use string_error::{into_err, static_err};
use binaryornot::is_binary;

fn get_command<P>(path: P) -> Result<Command, Box<dyn Error>>
where P: AsRef<Path>
{
    let bin = is_binary(path.as_ref()).unwrap_or_else(|e| panic!("Cannot open {}, error: {}", path.as_ref().to_string_lossy(), e));
    match path.as_ref().extension().and_then(OsStr::to_str).and_then(|s| s.split('.').last()) {
        Some("py") => get_python_command(path),
        Some("cpp") | Some("cxx") if !bin => panic!("internal error"),
        Some("exe") | Some("o") | None if bin => Ok(get_bin_command(path)),
        Some(x) if bin => {
            // Err(into_err(format!("unsupported binary file type {}", x)))
            println!("Warning! Running unconventional type extensions \"{}\"", x);
            Ok(get_bin_command(path))
        },
        Some(_) | None => Err(into_err(format!("textual input is not yet supported.")))
    }
}

fn preprocess_command<P>(path: P, args: &Cli) -> Result<PathBuf, Box<dyn Error>>
where P: AsRef<Path>
{
    let bin = is_binary(path.as_ref()).unwrap_or_else(|e| panic!("Cannot open {}, error: {}", path.as_ref().to_string_lossy(), e));
    match path.as_ref().extension().and_then(OsStr::to_str).and_then(|s| s.split('.').last()) {
        Some("cpp") | Some("cxx") if !bin => preprocess_cpp_command(path, args),
        Some(_) | None => Ok(PathBuf::from(path.as_ref())),
    }
}

fn get_bin_command<P>(path: P) -> Command
where P: AsRef<Path>
{
    Command::new(path.as_ref())
}

fn preprocess_cpp_command<P>(path: P, args: &Cli) -> Result<PathBuf, Box<dyn Error>>
where P: AsRef<Path>
{
    println!("Compiling {}", path.as_ref().to_str().unwrap());

    let compiler = ["g++", "clang"]
        .iter()
        .map(which::which)
        .find_map(|x| x.ok())
        .ok_or_else(|| static_err("couldn't find a c++ compiler! (support is present for g++ or clang only)"))?;

    let output_name = format!("./{}_{}.o", 
        path.as_ref().file_name().and_then(OsStr::to_str).expect("program has no filename!"), 
        compiler.file_name().unwrap().to_str().unwrap()
        );

    let command = format!("{} {} -o {}", 
        path.as_ref().to_str().unwrap(),
        args.cpp_compiler_flags,
        output_name
        );
    
    let process = Command::new(compiler.to_str().unwrap())
        .args(command.split(" "))
        .current_dir(current_dir().expect("process does not have cwd defined!"))
        .stdout(Stdio::piped())
        //.stderr(Stdio::piped())
        .spawn()?;

    let output = process
        .controlled_with_output()
        .wait()?
        .ok_or_else(|| static_err("couldn't start program"))?;

    let gen_errors = String::from_utf8(output.stderr).expect("error parsing string");
    if !gen_errors.is_empty() || !output.status.success()  {
        return Err(into_err(format!("couldn't compile file \"{}\", errors generated by compiler (\"{}\") should have appeared before. Command used: {} {}", 
            path.as_ref().to_str().unwrap(), 
            compiler.to_str().unwrap(),
            compiler.file_name().unwrap().to_str().unwrap(),
            command)));
    }

    Ok(PathBuf::from(output_name))
}

fn get_python_command<P>(path: P) -> Result<Command, Box<dyn Error>>
where P: AsRef<Path>
{
    let pyint = ["python", "python3", "python2"]
        .iter()
        .map(which::which)
        .find_map(|x| x.ok()) 
        .ok_or_else(|| static_err("cannot find a python intepreter!"))?;

    let mut cmd = Command::new(pyint);
    cmd.current_dir(current_dir()?);
    cmd.arg(path.as_ref().as_os_str());
    Ok(cmd)
}



// pub type Failure<'a> = (&'a Path, ExitStatus, String);
pub enum Failure<'a> {
    Prog(&'a Path, String, String),
    TimeLimit(&'a Path),
}
pub type Success<'a> = (&'a Path, String);
pub type Execution<'a> = Result<Success<'a>, Failure<'a>>;

pub fn generate_input(args: &Cli) -> Execution {
    execute_prog(args.generator.as_path())
}

fn get_execution_limits(args: &Cli) -> (Option<Duration>, Option<usize>) {
    let tlimit = args.time_limit.map(Duration::from_secs_f64);
    let mlimit = args.memory_limit.map(|x| x*1000); // convert from kilobytes to bytes
    (tlimit, mlimit)
}

pub fn execute_prog<'a>(path: &'a Path) -> Execution<'a>
{
    let gen = get_command(path)
        .expect("cannot open program")
        .output()
        .expect("cannot start program");

    let gen_errors = String::from_utf8(gen.stderr).expect("error parsing string");
    if !gen_errors.is_empty() || !gen.status.success()  {
        Err(Failure::Prog(path, gen.status.to_string(), gen_errors))
    } else {
        Ok((path, String::from_utf8(gen.stdout).expect("cannot parse string")))
    }
}

pub fn start_prog_input<P>(path: P, input: &str) -> Child
where P: AsRef<Path>
{
    let mut gen = get_command(path)
        .expect("cannot open program")
        .stdin(Stdio::piped())
        .stderr(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("cannot start program");

    let mut stdin = gen.stdin.take().expect("failed to open stdin");
    stdin.write_all(input.as_bytes()).expect("failed to write input!");
    gen
}

pub fn start_prog_input_limits<P>(path: P, input: &str, args: &Cli) -> Option<process_control::Output>
where P: AsRef<Path>
{
    let (tlimit, mlimit) = get_execution_limits(args);

    let mut gen = get_command(&path)
        .expect("cannot open program")
        .stdin(Stdio::piped())
        .stderr(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect(format!("coudln't start program {}", path.as_ref().to_str().unwrap()).as_str());

    let mut stdin = gen.stdin.take().expect("failed to open stdin");
    stdin.write_all(input.as_bytes()).expect("failed to write input!");
    
    let mut gen = gen
        .controlled_with_output();

    if let Some(t) = tlimit {
        gen = gen.time_limit(t);
    }
    #[cfg(process_control_memory_limit)]
    if let Some(m) = mlimit {
        gen = gen.memory_limit(m);
    }
    #[cfg(not(process_control_memory_limit))]
    if mlimit.is_some() {
        panic!("Memory limit cannot be set on this platofrm [NOT SUPPORTED]")
    }
        
    gen
        .terminate_for_timeout()
        .wait()
        .expect("couldn't wait for the programme!")
}

pub fn output_to_execution(out: Output, path: & Path) -> Execution
{
    let gen_errors = String::from_utf8(out.stderr).expect("error parsing string");
    if !gen_errors.is_empty() || !out.status.success() {
        Err(Failure::Prog(path, out.status.to_string(), gen_errors))
    } else {
        Ok((path, String::from_utf8(out.stdout).expect("cannot parse string")))
    }
}

pub fn execute_prog_input_limits<'a>(path: &'a Path, input: &str, args: &Cli) -> Execution<'a>
{
    let out = start_prog_input_limits(path, input, args);    
    match out {
        None => Err(Failure::TimeLimit(path)),
        Some(out) => {
            let gen_errors = String::from_utf8(out.stderr).expect("error parsing string");
            if !gen_errors.is_empty() || !out.status.success() {
                Err(Failure::Prog(path, out.status.to_string(), gen_errors))
            } else {
                Ok((path, String::from_utf8(out.stdout).expect("cannot parse string")))
            }
        }
    }
}

pub fn execute_prog_input<'a>(path: &'a Path, input: &str) -> Execution<'a>
{
    let gen = start_prog_input(path, input);
    let out = gen.wait_with_output().expect("failed to read stdout and stderr");
    output_to_execution(out, path)
}

pub fn execute_progs_input<'a, I>(paths: I, input: &str) -> Vec<Execution<'a>>
where I: Iterator<Item = &'a Path>, 
{
    paths
        .map(|path| (path, start_prog_input(path, input)))
        .map(|(path, child)| (path, child.wait_with_output().expect("failed to read stdout and stderr")))
        .map(|(path, child)| output_to_execution(child, path))
        .collect()
}

pub enum Round<'a>{
    GeneratorFail(Failure<'a>),
    ReferenceFails(String, Vec<Failure<'a>>),
    ProgramFail(String, Failure<'a>),
    Success(String, Success<'a>, Vec<Success<'a>>),
}

pub fn run_round(args: &Cli) -> Round {
    if args.verbose { println!("round start"); }
    let inp = generate_input(args);
    if let Err(x) = inp { return Round::GeneratorFail(x); }
    let inp = unsafe{ inp.unwrap_unchecked() };
    if args.verbose { println!("finished generating input"); }

    let prg = if args.time_limit.is_none() { 
        execute_prog_input(args.program.as_path(), inp.1.as_str())
    } else {
        execute_prog_input_limits(args.program.as_path(), inp.1.as_str(), args)
    };
    if args.verbose { println!("finished executing program"); }
    if let Err(x) = prg { return Round::ProgramFail(inp.1, x); }
    let prq = unsafe{ prg.unwrap_unchecked() };

    let refs = args.reference.iter()
        .map(PathBuf::as_path);
    let refs = execute_progs_input(refs, inp.1.as_str());
    if args.verbose { println!("finished executing references"); }

    if refs.iter().any(|x| x.is_err()) { 
        let r = refs.into_iter().filter_map(|x| x.err()).collect();
        Round::ReferenceFails(inp.1, r)
    } else { 
        let r = refs.into_iter().map(|x| unsafe{ x.unwrap_unchecked() }).collect();
        Round::Success(inp.1, prq, r)
    }
}

pub enum Mismatch<'a>{
    AllMatch,
    RefMismatch(Vec<Success<'a>>),
    ProgMismatch(Success<'a>, Vec<Success<'a>>),
}

pub fn test_mismatch<'a>(prog: Success<'a>, refs: Vec<Success<'a>>) -> Mismatch<'a> {
    if refs.iter().all(|x| x.1 == prog.1) { return Mismatch::AllMatch; }

    // just a random string which will should never be the output
    // indeed it is impossible that the \0 is at the beginning
    let bad = String::from("\0\0\0\t@"); 
    let bad = refs
        .iter()
        .map(|x| &x.1)
        .filter(|x| x != &&prog.1)
        .reduce(|a, i| if a == i { a } else { &bad } )
        .unwrap()
        == &bad;
        
    if bad { Mismatch::RefMismatch(refs) }
    else { 
        let refs = refs.into_iter().filter(|x| x.1 != prog.1).collect();
        Mismatch::ProgMismatch(prog, refs) 
    }
}

